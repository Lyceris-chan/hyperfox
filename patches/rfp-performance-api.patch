# Backport of https://phabricator.services.mozilla.com/D167444
# Should land in 111.0
--- a/dom/performance/Performance.cpp
+++ b/dom/performance/Performance.cpp
@@ -163,29 +163,17 @@
                                   JS::Handle<JSObject*> aGivenProto) {
   return Performance_Binding::Wrap(aCx, this, aGivenProto);
 }
 
 void Performance::GetEntries(nsTArray<RefPtr<PerformanceEntry>>& aRetval) {
-  // We return an empty list when 'privacy.resistFingerprinting' is on.
-  if (nsContentUtils::ShouldResistFingerprinting()) {
-    aRetval.Clear();
-    return;
-  }
-
   aRetval = mResourceEntries.Clone();
   aRetval.AppendElements(mUserEntries);
   aRetval.Sort(PerformanceEntryComparator());
 }
 
 void Performance::GetEntriesByType(
     const nsAString& aEntryType, nsTArray<RefPtr<PerformanceEntry>>& aRetval) {
-  // We return an empty list when 'privacy.resistFingerprinting' is on.
-  if (nsContentUtils::ShouldResistFingerprinting()) {
-    aRetval.Clear();
-    return;
-  }
-
   if (aEntryType.EqualsLiteral("resource")) {
     aRetval = mResourceEntries.Clone();
     return;
   }
 
@@ -204,15 +192,10 @@
 void Performance::GetEntriesByName(
     const nsAString& aName, const Optional<nsAString>& aEntryType,
     nsTArray<RefPtr<PerformanceEntry>>& aRetval) {
   aRetval.Clear();
 
-  // We return an empty list when 'privacy.resistFingerprinting' is on.
-  if (nsContentUtils::ShouldResistFingerprinting()) {
-    return;
-  }
-
   RefPtr<nsAtom> name = NS_Atomize(aName);
   RefPtr<nsAtom> entryType =
       aEntryType.WasPassed() ? NS_Atomize(aEntryType.Value()) : nullptr;
 
   if (entryType) {
@@ -365,21 +348,11 @@
       PerformanceMark::Constructor(global, aName, aMarkOptions, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
-  // To avoid fingerprinting in User Timing L2, we didn't add marks to the
-  // buffer so the user could not get timing data (which can be used to
-  // fingerprint) from the API. This may no longer be necessary (since
-  // performance.now() has reduced precision to protect against fingerprinting
-  // and performance.mark's primary fingerprinting issue is probably this timing
-  // data) but we need to do a more thorough reanalysis before we remove the
-  // fingerprinting protection. For now, we preserve the User Timing L2 behavior
-  // while supporting User Timing L3.
-  if (!nsContentUtils::ShouldResistFingerprinting()) {
-    InsertUserEntry(performanceMark);
-  }
+  InsertUserEntry(performanceMark);
 
   if (profiler_thread_is_being_profiled_for_markers()) {
     Maybe<uint64_t> innerWindowId;
     if (GetOwner()) {
       innerWindowId = Some(GetOwner()->WindowID());
@@ -595,23 +568,10 @@
   if (!GetParentObject()) {
     aRv.ThrowInvalidStateError("Global object is unavailable");
     return nullptr;
   }
 
-  // When resisting fingerprinting, we don't add marks to the buffer. Since
-  // measure relies on relationships between marks in the buffer, this method
-  // will throw if we look for user-entered marks so we return a dummy measure
-  // instead of continuing. We could instead return real values for performance
-  // timing attributes and dummy values for user-entered marks but this adds
-  // complexity that doesn't seem worth the effort because these fingerprinting
-  // protections may not longer be necessary (since performance.now() already
-  // has reduced precision).
-  if (nsContentUtils::ShouldResistFingerprinting()) {
-    return do_AddRef(new PerformanceMeasure(GetParentObject(), aName, 0, 0,
-                                            JS::NullHandleValue));
-  }
-
   // Maybe is more readable than using the union type directly.
   Maybe<const PerformanceMeasureOptions&> options;
   if (aStartOrMeasureOptions.IsPerformanceMeasureOptions()) {
     options.emplace(aStartOrMeasureOptions.GetAsPerformanceMeasureOptions());
   }
@@ -811,10 +811,6 @@ MOZ_ALWAYS_INLINE bool Performance::CanAddResourceTimingEntry() {
 void Performance::InsertResourceEntry(PerformanceEntry* aEntry) {
   MOZ_ASSERT(aEntry);
 
-  if (nsContentUtils::ShouldResistFingerprinting()) {
-    return;
-  }
-
   /*
    * Let new entry be the input PerformanceEntry to be added.
    *
--- a/dom/performance/PerformanceMainThread.cpp
+++ b/dom/performance/PerformanceMainThread.cpp
@@ -409,12 +409,11 @@
 }
 
 void PerformanceMainThread::CreateNavigationTimingEntry() {
   MOZ_ASSERT(!mDocEntry, "mDocEntry should be null.");
 
-  if (!StaticPrefs::dom_enable_performance_navigation_timing() ||
-      StaticPrefs::privacy_resistFingerprinting()) {
+  if (!StaticPrefs::dom_enable_performance_navigation_timing()) {
     return;
   }
 
   nsAutoString name;
   GetURLSpecFromChannel(mChannel, name);
@@ -461,16 +460,10 @@
   return mEventCounts;
 }
 
 void PerformanceMainThread::GetEntries(
     nsTArray<RefPtr<PerformanceEntry>>& aRetval) {
-  // We return an empty list when 'privacy.resistFingerprinting' is on.
-  if (nsContentUtils::ShouldResistFingerprinting()) {
-    aRetval.Clear();
-    return;
-  }
-
   aRetval = mResourceEntries.Clone();
   aRetval.AppendElements(mUserEntries);
 
   if (mDocEntry) {
     aRetval.AppendElement(mDocEntry);
@@ -482,16 +475,10 @@
   aRetval.Sort(PerformanceEntryComparator());
 }
 
 void PerformanceMainThread::GetEntriesByType(
     const nsAString& aEntryType, nsTArray<RefPtr<PerformanceEntry>>& aRetval) {
-  // We return an empty list when 'privacy.resistFingerprinting' is on.
-  if (nsContentUtils::ShouldResistFingerprinting()) {
-    aRetval.Clear();
-    return;
-  }
-
   RefPtr<nsAtom> type = NS_Atomize(aEntryType);
   if (type == nsGkAtoms::navigation) {
     aRetval.Clear();
 
     if (mDocEntry) {
@@ -524,16 +511,10 @@
 }
 
 void PerformanceMainThread::GetEntriesByName(
     const nsAString& aName, const Optional<nsAString>& aEntryType,
     nsTArray<RefPtr<PerformanceEntry>>& aRetval) {
-  // We return an empty list when 'privacy.resistFingerprinting' is on.
-  if (nsContentUtils::ShouldResistFingerprinting()) {
-    aRetval.Clear();
-    return;
-  }
-
   Performance::GetEntriesByName(aName, aEntryType, aRetval);
 
   if (mFCPTiming && mFCPTiming->GetName()->Equals(aName) &&
       (!aEntryType.WasPassed() ||
        mFCPTiming->GetEntryType()->Equals(aEntryType.Value()))) {
--- a/dom/performance/PerformanceNavigationTiming.cpp
+++ b/dom/performance/PerformanceNavigationTiming.cpp
@@ -150,8 +150,7 @@
     nsIHttpChannel* aHttpChannel, nsITimedChannel* aChannel) {
   mTimingData->SetPropertiesFromHttpChannel(aHttpChannel, aChannel);
 }
 
 bool PerformanceNavigationTiming::Enabled(JSContext* aCx, JSObject* aGlobal) {
-  return (StaticPrefs::dom_enable_performance_navigation_timing() &&
-          !StaticPrefs::privacy_resistFingerprinting());
+  return StaticPrefs::dom_enable_performance_navigation_timing();
 }
--- a/dom/performance/PerformanceTiming.cpp
+++ b/dom/performance/PerformanceTiming.cpp
@@ -110,12 +110,11 @@
       mTimingAllowed(true),
       mInitialized(false) {
   mInitialized = !!aChannel;
   mZeroTime = aZeroTime;
 
-  if (!StaticPrefs::dom_enable_performance() ||
-      nsContentUtils::ShouldResistFingerprinting()) {
+  if (!StaticPrefs::dom_enable_performance()) {
     mZeroTime = 0;
   }
 
   nsCOMPtr<nsIURI> uri;
   if (aHttpChannel) {
@@ -336,24 +335,22 @@
   // header with the domain of the page that started the load.
   return aChannel->TimingAllowCheck(principal);
 }
 
 uint8_t PerformanceTimingData::GetRedirectCount() const {
-  if (!StaticPrefs::dom_enable_performance() || !IsInitialized() ||
-      nsContentUtils::ShouldResistFingerprinting()) {
+  if (!StaticPrefs::dom_enable_performance() || !IsInitialized()) {
     return 0;
   }
   if (!mAllRedirectsSameOrigin) {
     return 0;
   }
   return mRedirectCount;
 }
 
 bool PerformanceTimingData::ShouldReportCrossOriginRedirect(
     bool aEnsureSameOriginAndIgnoreTAO) const {
-  if (!StaticPrefs::dom_enable_performance() || !IsInitialized() ||
-      nsContentUtils::ShouldResistFingerprinting()) {
+  if (!StaticPrefs::dom_enable_performance() || !IsInitialized()) {
     return false;
   }
 
   if (!mTimingAllowed || mRedirectCount == 0) {
     return false;

